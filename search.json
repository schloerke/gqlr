[{"path":"http://schloerke.com/gqlr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Barret Schloerke. Author, maintainer. Ryan Hafen. Thesis advisor. GraphQL. Copyright holder.            http://graphql.github.io/graphql-spec/","code":""},{"path":"http://schloerke.com/gqlr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Schloerke B (2022). gqlr: 'GraphQL' Server R. http://schloerke.com/gqlr/, https://github.com/schloerke/gqlr, http://graphql.github.io/graphql-spec/, http://graphql.org.","code":"@Manual{,   title = {gqlr: 'GraphQL' Server in R},   author = {Barret Schloerke},   year = {2022},   note = {http://schloerke.com/gqlr/, https://github.com/schloerke/gqlr, http://graphql.github.io/graphql-spec/, http://graphql.org}, }"},{"path":[]},{"path":"http://schloerke.com/gqlr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"GraphQL Server in R","text":"GraphQL data “query language created Facebook 2015 describing capabilities requirements data models client‐server applications”. GraphQL specification can read hosted GitHub. cliff notes version described GraphQL’s GitHub. learn GraphQL language, highly recommend GraphQL’s website. package pulls inspiration graphql-js Mathew Mueller’s graph.ql. wanted full functionality GraphQL, didn’t want force users write full object definitions can already defined GraphQL syntax. gqlr merges R’s rapid development speed consistent query language GraphQL.","code":""},{"path":"http://schloerke.com/gqlr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"GraphQL Server in R","text":"encounter clear bug, please file minimal reproducible example GitHub.","code":"# The development version from GitHub: # install.packages(\"devtools\") devtools::install_github(\"schloerke/gqlr\")"},{"path":[]},{"path":"http://schloerke.com/gqlr/index.html","id":"hello-world","dir":"","previous_headings":"Usage","what":"Hello World","title":"GraphQL Server in R","text":"","code":"library(magrittr) library(gqlr)  schema <- \"   type Hello {     world: String   }   schema {     query: Hello   } \" %>%   gqlr_schema()  execute_request(\"{world}\", schema, initial_value = list(world = \"Hi!\")) # { #   \"data\": { #     \"world\": \"Hi!\" #   } # }"},{"path":[]},{"path":"http://schloerke.com/gqlr/index.html","id":"star-wars-data","dir":"","previous_headings":"Usage > Star Wars","what":"Star Wars Data","title":"GraphQL Server in R","text":"","code":"add_human <- function(human_data, id, name, appear, home, friend) {   human <- list(id = id, name = name, appearsIn = appear, friends = friend, homePlanet = home)   # set up a function to be calculated if the field totalCredits is required   human$totalCredits <- function(obj, args, schema) {     length(human$appearsIn)   }   human_data[[id]] <- human   human_data } add_droid <- function(droid_data, id, name, appear, pf, friend) {   droid <- list(id = id, name = name, appearsIn = appear, friends = friend, primaryFunction = pf)   # set extra fields manually   droid$totalCredits <- length(droid$appearsIn)   droid_data[[id]] <- droid   droid_data }  human_data <- list() %>%   add_human(\"1000\", \"Luke Skywalker\", c(4, 5, 6), \"Tatooine\", c(\"1002\", \"1003\", \"2000\", \"2001\")) %>%   add_human(\"1002\", \"Han Solo\",       c(4, 5, 6), \"Corellia\", c(\"1000\", \"1003\", \"2001\")) %>%   add_human(\"1003\", \"Leia Organa\",    c(4, 5, 6), \"Alderaan\", c(\"1000\", \"1002\", \"2000\", \"2001\"))  droid_data <- list() %>%   add_droid(\"2000\", \"C-3PO\", c(4, 5, 6), \"Protocol\", c(\"1000\", \"1002\", \"1003\", \"2001\")) %>%   add_droid(\"2001\", \"R2-D2\", c(4, 5, 6), \"Astromech\", c(\"1000\", \"1002\", \"1003\"))  all_characters <- list() %>% append(human_data) %>% append(droid_data) all_characters[[1]] # $id # [1] \"1000\" # # $name # [1] \"Luke Skywalker\" # # $appearsIn # [1] 4 5 6 # # $friends # [1] \"Tatooine\" # # $homePlanet # [1] \"1002\" \"1003\" \"2000\" \"2001\" # # $totalCredits # function (obj, args, schema) # { #     length(human$appearsIn) # } # <environment: 0x7fadd8ca2038>"},{"path":"http://schloerke.com/gqlr/index.html","id":"star-wars-schema","dir":"","previous_headings":"Usage > Star Wars","what":"Star Wars Schema","title":"GraphQL Server in R","text":"","code":"\" enum Episode { NEWHOPE, EMPIRE, JEDI }  interface Character {   id: String!   name: String   friends: [Character]   appearsIn: [Episode] }  type Droid implements Character {   id: String!   name: String   friends: [Character]   appearsIn: [Episode]   primaryFunction: String } type Human implements Character {   id: String!   name: String   friends: [Character]   appearsIn: [Episode]   homePlanet: String }  type Query {   hero(episode: Episode): Character   human(id: String!): Human   droid(id: String!): Droid } # the schema type must be provided if a query or mutation is to be executed schema {   query: Query } \" %>%   gqlr_schema(     Episode = list(       resolve = function(episode_id, schema) {         switch(as.character(episode_id),           \"4\" = \"NEWHOPE\",           \"5\" = \"EMPIRE\",           \"6\" = \"JEDI\",           \"UNKNOWN_EPISODE\"         )       }     ),     Character = list(       resolve_type = function(id, schema) {         ifelse(id %in% names(droid_data), \"Droid\", \"Human\")       }     ),     Human = list(       # Add a resolve method for type Human that takes in an id and returns the human data       resolve = function(id, args, schema) {         human_data[[id]]       }     ),     Droid = list(       # description for Droid       description = \"A mechanical creature in the Star Wars universe.\",       # Add a resolve method for type Droid that takes in an id and returns the droid data       resolve = function(id, schema) {         droid_data[[id]]       }     ),     Query = function(null, schema) {       list(         # return a function for key 'hero'         # the id will be resolved by the appropriate resolve() method of Droid or Human         hero = function(obj, args, schema) {           episode <- args$episode           if (identical(episode, 5) || identical(episode, \"EMPIRE\")) {             \"1000\" # Luke           } else {             \"2001\" # R2-D2           }         },         # the id will be resolved by the Human resolve() method         human = function(obj, args, schema) {           args$id         },         # the id will be resolved by the Droid resolve() method         droid = function(obj, args, schema) {           args$id         }       )     }   ) -> star_wars_schema"},{"path":"http://schloerke.com/gqlr/index.html","id":"star-wars-execution","dir":"","previous_headings":"Usage > Star Wars","what":"Star Wars Execution","title":"GraphQL Server in R","text":"","code":"# Use the resolve method to initialize the data \" {   hero {     id     name     friends {       id       name     }   } } \" %>%   execute_request(star_wars_schema) # { #   \"data\": { #     \"hero\": { #       \"id\": \"2001\", #       \"name\": \"R2-D2\", #       \"friends\": [ #         { #           \"id\": \"1000\", #           \"name\": \"Luke Skywalker\" #         }, #         { #           \"id\": \"1002\", #           \"name\": \"Han Solo\" #         }, #         { #           \"id\": \"1003\", #           \"name\": \"Leia Organa\" #         } #       ] #     } #   } # }   # Use variables... \" query FetchSomeIDQuery($someId: String!) {   human(id: $someId) {     name   } } \" %>%   execute_request(star_wars_schema, variables = list(someId = \"1000\")) # { #   \"data\": { #     \"human\": { #       \"name\": \"Luke Skywalker\" #     } #   } # }   # Introspection \" query IntrospectionTypeQuery {   __type(name: \\\"Droid\\\") {     kind     name     fields {       name     }   } } \" %>%   execute_request(star_wars_schema) # { #   \"data\": { #     \"__type\": { #       \"kind\": \"OBJECT\", #       \"name\": \"Droid\", #       \"fields\": [ #         { #           \"name\": \"id\" #         }, #         { #           \"name\": \"name\" #         }, #         { #           \"name\": \"friends\" #         }, #         { #           \"name\": \"appearsIn\" #         }, #         { #           \"name\": \"primaryFunction\" #         }, #         { #           \"name\": \"__typename\" #         } #       ] #     } #   } # }"},{"path":"http://schloerke.com/gqlr/index.html","id":"star-wars-server","dir":"","previous_headings":"Usage > Star Wars","what":"Star Wars Server","title":"GraphQL Server in R","text":"Explore curl","code":"# R gqlr:::server(star_wars_schema, log = TRUE) # forgot to export # GET R2-D2 and his friends' names curl '127.0.0.1:8000/graphql?query=%7Bhero%7Bname%7D%7D&pretty=TRUE' # { #   \"data\": { #     \"hero\": { #       \"name\": \"R2-D2\" #     } #   } # }  # POST for R2-D2 and his friends' names (no need to url escape the query) curl --data '{\"query\":\"{hero{name}}\"}' '127.0.0.1:8000/graphql' # defaults to parse as JSON # {\"data\":{\"hero\":{\"name\":\"R2-D2\"}}}  curl --data '{\"query\":\"{hero{name}}\"}' '127.0.0.1:8000/graphql' --header \"Content-Type:application/json\" # {\"data\":{\"hero\":{\"name\":\"R2-D2\"}}}  curl --data '{hero{name}}' '127.0.0.1:8000/graphql' --header \"Content-Type:application/graphql\" # {\"data\":{\"hero\":{\"name\":\"R2-D2\"}}}   # GET Schema definition curl '127.0.0.1:8000/' # enum Episode { #   NEWHOPE #   EMPIRE #   JEDI # } # # type Droid implements Character { #   id: String! #   name: String #   friends: [Character] #   appearsIn: [Episode] #   primaryFunction: String # } # # type Human implements Character { #   id: String! #   name: String #   friends: [Character] #   appearsIn: [Episode] #   homePlanet: String # } # # type Query { #   hero(episode: Episode): Character #   human(id: String!): Human #   droid(id: String!): Droid # } # # interface Character { #   id: String! #   name: String #   friends: [Character] #   appearsIn: [Episode] # } # # schema { #   query: Query # }"},{"path":"http://schloerke.com/gqlr/index.html","id":"presentations","dir":"","previous_headings":"","what":"Presentations","title":"GraphQL Server in R","text":"WOMBAT2016 Melbourne, Australia; Feb 2016.","code":""},{"path":"http://schloerke.com/gqlr/index.html","id":"other-r-graphql-related-packages","dir":"","previous_headings":"","what":"Other R GraphQL related packages","title":"GraphQL Server in R","text":"Bindings libgraphqlparser R. gqlr uses package parse requests strings schema strings json General purpose GraphQL client ghql client used submit requests gqlr server executed","code":""},{"path":"http://schloerke.com/gqlr/reference/ErrorList.html","id":null,"dir":"Reference","previous_headings":"","what":"ErrorList — ErrorList","title":"ErrorList — ErrorList","text":"Handles errors occur query validation. object returned execute request function (ans <- execute_request(query, schema)) field 'error_list' (ans$error_list).","code":""},{"path":"http://schloerke.com/gqlr/reference/ErrorList.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ErrorList — ErrorList","text":"","code":"answer <- execute_request(my_request, my_schema) answer$error_list"},{"path":"http://schloerke.com/gqlr/reference/ErrorList.html","id":"initialize","dir":"Reference","previous_headings":"","what":"Initialize","title":"ErrorList — ErrorList","text":"verbose boolean determines errors printed occurrence.  Defaults TRUE","code":""},{"path":"http://schloerke.com/gqlr/reference/ErrorList.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ErrorList — ErrorList","text":"$n count errors received $errors list error information $verbose boolean determines errors printed received $has_no_errors() helper method determine errors $has_any_errors() helper method determine errors $get_sub_source(loc) helper method display subsection source text given Location information $add(rule_code, ...) add new error according rule_code provided. Remaining arguments passed directly paste(..., sep = \"\") extra error rule information $.format(...) formats error list user friendly text. Remaining arguments ignored $print(...) prints error list calling self$format(...)","code":""},{"path":"http://schloerke.com/gqlr/reference/ErrorList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ErrorList — ErrorList","text":"","code":"error_list <- ErrorList$new() error_list #> <ErrorList> No errors  error_list$has_any_errors() # FALSE #> [1] FALSE error_list$has_no_errors() # TRUE #> [1] TRUE  error_list$add(\"3.1.1\", \"Multiple part\", \" error about Scalars\") #> Error: #> * 3.1.1: Scalars #>   Multiple part error about Scalars error_list #> <ErrorList> #> Errors:  #> 3.1.1: Scalars #> Multiple part error about Scalars  error_list$has_any_errors() # TRUE #> [1] TRUE error_list$has_no_errors() # FALSE #> [1] FALSE"},{"path":"http://schloerke.com/gqlr/reference/Schema.html","id":null,"dir":"Reference","previous_headings":"","what":"GraphQL Schema object — Schema","title":"GraphQL Schema object — Schema","text":"Manages GraphQL schema definition.  Schema can add GraphQL type definitions, assist determining definition types, retrieve particular definitions, can combine schema definitions. Typically, Schema class objects created using gqlr_schema.  Creating Schema$new() object reserved multiple Schema objects combined.","code":""},{"path":"http://schloerke.com/gqlr/reference/Schema.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GraphQL Schema object — Schema","text":"","code":"## using star_wars_schema from # example(gqlr_schema) star_wars_schema$get_schema() star_wars_schema$is_enum(\"Episode\") # TRUE star_wars_schema$is_object(\"Episode\") # FALSE execute_request(\"{ hero { name } }\", star_wars_schema)"},{"path":"http://schloerke.com/gqlr/reference/Schema.html","id":"initialize","dir":"Reference","previous_headings":"","what":"Initialize","title":"GraphQL Schema object — Schema","text":"schema Either character GraphQL definition schema another Schema object.  Extending methods descriptions added gqlr_schema initialize function automatically add Scalars: Int, Float, String, Boolean Directives: @skip @include Introspection Capabilities","code":""},{"path":"http://schloerke.com/gqlr/reference/Schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"GraphQL Schema object — Schema","text":"$add(obj): function add either another Schema's definitions Document definitions.  obj must inherit class either 'Schema' 'Document' $is_scalar(name), $is_enum(name), $is_object(name), $is_interface(name), $is_union(name), $is_input_object(name), $is_directive(name), $is_value(name): methods determine definition corresponding definition type provided name. $get_scalar(name), $get_enum(name), $get_object(name), $get_interface(name), $get_union(name), $get_input_object(name), $get_directive(name), $get_value(name): methods retrieve definition corresponding definition type provided name. object found, NULL returned. printed, quickly conveys known information definition.  Due nature R6 objects, definitions may retrieved altered retrieval.  helpful adding descriptions resolve initialization. $get_scalars(name), $get_enums(name), $get_objects(name), $get_interfaces(name), $get_unions(name), $get_input_objects(name), $get_directives(name), $get_values(name): methods retrieve definitions corresponding definition type. $get_type(name): method retrieve object unknown type. object found, NULL returned. printed, quickly conveys known information definition. $get_type(name): method retrieve object unknown type. object found, NULL returned. $get_schema(): method retrieve full definition schema. printed, quickly conveys types schema. $get_query_object(), $get_mutation_object(): helper method retrieve schema definition query mutation object. $implements_interface(): helper method retrieve objects implement particular interface. $is_valid: boolean determines Schema object validated.  Schema objects validated time request execution.  Schema remain valid new definitions added.","code":""},{"path":[]},{"path":"http://schloerke.com/gqlr/reference/as_R6.html","id":null,"dir":"Reference","previous_headings":"","what":"As R6 — as_R6","title":"As R6 — as_R6","text":"Debug method strips gqlr classes assigns class 'R6'","code":""},{"path":"http://schloerke.com/gqlr/reference/as_R6.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"As R6 — as_R6","text":"","code":"as_R6(x)"},{"path":"http://schloerke.com/gqlr/reference/as_R6.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"As R6 — as_R6","text":"x object. inherits 'R6', class x set 'R6'","code":""},{"path":"http://schloerke.com/gqlr/reference/as_R6.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"As R6 — as_R6","text":"","code":"Int <- getFromNamespace(\"Int\", \"gqlr\")$clone() print(Int) #> <graphql definition> #>   | scalar Int print(as_R6(Int)) #> <R6> #>   Public: #>     .argNames: active binding #>     .args: list #>     .format: function (...)  #>     .parse_ast: active binding #>     .resolve: active binding #>     .title: active binding #>     clone: function (deep = FALSE)  #>     description: active binding #>     directives: active binding #>     initialize: function (loc = NULL, description = NULL, name, directives = NULL,  #>     loc: active binding #>     name: active binding"},{"path":"http://schloerke.com/gqlr/reference/execute_request.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute GraphQL server response — execute_request","title":"Execute GraphQL server response — execute_request","text":"Executes GraphQL server request provided request.","code":""},{"path":"http://schloerke.com/gqlr/reference/execute_request.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute GraphQL server response — execute_request","text":"","code":"execute_request(   request,   schema,   ...,   operation_name = NULL,   variables = list(),   initial_value = NULL,   verbose_errors = is_interactive() )"},{"path":"http://schloerke.com/gqlr/reference/execute_request.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute GraphQL server response — execute_request","text":"request valid GraphQL string schema character string (used along side initial_value) schema object created gqlr_schema ... ignored paramter expansion operation_name name request operation execute. value provided use operation request string. one operations exist, error produced.  See https://graphql.github.io/graphql-spec/October2016/#GetOperation() variables named list containing variable values. https://graphql.github.io/graphql-spec/October2016/#sec-Language.Variables initial_value default value executing requests.  value can either provided /combined resolve method query root type mutation root type.  value provided named list field name (key) value matching field name type.  value may function returns value field name type. verbose_errors logical determine error-like messages displayed processing request finds unknown structures. default, enabled verbose_errors = rlang::is_interactive() TRUE.","code":""},{"path":"http://schloerke.com/gqlr/reference/execute_request.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Execute GraphQL server response — execute_request","text":"https://graphql.github.io/graphql-spec/October2016/#sec-Execution","code":""},{"path":"http://schloerke.com/gqlr/reference/execute_request.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute GraphQL server response — execute_request","text":"","code":"# \\donttest{ # bare bones schema <- gqlr_schema(\"   type Person {     name: String     friends: [Person]   }   schema {     query: Person   } \")  data <- list(   name = \"Barret\",   friends = list(     list(name = \"Ryan\", friends = list(list(name = \"Bill\"), list(name = \"Barret\"))),     list(name = \"Bill\", friends = list(list(name = \"Ryan\")))   ) )  ans <- execute_request(\"{ name }\", schema, initial_value = data) ans$as_json() #> { #>   \"data\": { #>     \"name\": \"Barret\" #>   } #> }   execute_request(\"   {     name     friends {       name       friends {         name         friends {           name         }       }     }   }\",   schema,   initial_value = data )$as_json() #> { #>   \"data\": { #>     \"name\": \"Barret\", #>     \"friends\": [ #>       { #>         \"name\": \"Ryan\", #>         \"friends\": [ #>           { #>             \"name\": \"Bill\", #>             \"friends\": null #>           }, #>           { #>             \"name\": \"Barret\", #>             \"friends\": null #>           } #>         ] #>       }, #>       { #>         \"name\": \"Bill\", #>         \"friends\": [ #>           { #>             \"name\": \"Ryan\", #>             \"friends\": null #>           } #>         ] #>       } #>     ] #>   } #> }        # Using resolve method to help with recursion people <- list(   \"id_Barret\" = list(name = \"Barret\", friends = list(\"id_Ryan\", \"id_Bill\")),   \"id_Ryan\" = list(name = \"Ryan\", friends = list(\"id_Barret\", \"id_Bill\")),   \"id_Bill\" = list(name = \"Bill\", friends = list(\"id_Ryan\")) ) schema <- gqlr_schema(\"     type Person {       name: String       friends: [Person]     }     schema {       query: Person     }   \",   Person = list(     resolve = function(name, schema, ...) {       if (name %in% names(people)) {         people[[name]]       } else {         NULL       }     }   ) )  ans <- execute_request(\"{ name }\", schema, initial_value = \"id_Barret\") ans$as_json() #> { #>   \"data\": { #>     \"name\": \"Barret\" #>   } #> }   execute_request(\"   {     name     friends {       name       friends {         name         friends {           name         }       }     }   }\",   schema,   initial_value = \"id_Barret\" )$as_json() #> { #>   \"data\": { #>     \"name\": \"Barret\", #>     \"friends\": [ #>       { #>         \"name\": \"Ryan\", #>         \"friends\": [ #>           { #>             \"name\": \"Barret\", #>             \"friends\": [ #>               { #>                 \"name\": \"Ryan\" #>               }, #>               { #>                 \"name\": \"Bill\" #>               } #>             ] #>           }, #>           { #>             \"name\": \"Bill\", #>             \"friends\": [ #>               { #>                 \"name\": \"Ryan\" #>               } #>             ] #>           } #>         ] #>       }, #>       { #>         \"name\": \"Bill\", #>         \"friends\": [ #>           { #>             \"name\": \"Ryan\", #>             \"friends\": [ #>               { #>                 \"name\": \"Barret\" #>               }, #>               { #>                 \"name\": \"Bill\" #>               } #>             ] #>           } #>         ] #>       } #>     ] #>   } #> }  # }"},{"path":"http://schloerke.com/gqlr/reference/gqlr_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Schema definitions — gqlr_schema","title":"Create Schema definitions — gqlr_schema","text":"Creates Schema object defined GraphQL string   inserts provided descriptions, resolve methods, resolve_type methods   appropriate place.","code":""},{"path":"http://schloerke.com/gqlr/reference/gqlr_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Schema definitions — gqlr_schema","text":"","code":"gqlr_schema(schema, ...)"},{"path":"http://schloerke.com/gqlr/reference/gqlr_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Schema definitions — gqlr_schema","text":"schema GraphQL schema string Schema object ... named lists information help produce schema definition. See Details","code":""},{"path":"http://schloerke.com/gqlr/reference/gqlr_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Schema definitions — gqlr_schema","text":"... named arguments whose values lists   information.  information needed type described . ScalarTypeDefinition: resolve function two   parameters: x (raw parsed, 5.0) schema   (full Schema definition). return parsed value description (optional) single character value describes   Scalar definition parse_ast (optional) function two   parameters: obj (GraphQL wrapped raw value, object   class IntValue value 5) schema (full Schema   definition).  function returns NULL AST   parsed. EnumTypeDefinition: resolve (optional) function two   parameters: x schema (full Schema definition).   return value x represents, Star Wars Episode enum   value \"4\" represent Episode \"NEWHOPE\". default,   EnumTypeDefinitions return current value. description (optional) single character value describes   Enum definition values (optional) named list enum value   descriptions. values = list(ENUMA = \"description ENUMA\",   ENUMZ = \"description ENUMZ\") ObjectTypeDefinition: resolve function two   parameters: x (place holder value expanded named list)   schema (full Schema definition). using resolve   method, recursive relationships, friends, can easily handled.   resolve function return fully named list fields   definition defines.  Missing fields automatically interpreted   NULL. Values returned list may function form   function(obj, args, schema) {...}.  allows fields   determined dynamically lazily. See add_human makes field   totalCredits, add_droid pre computes   information. description (optional) single character value   describes object fields (optional) named list field   descriptions. fields = list(fieldA = \"description field   \", fieldB = \"description field B\") InterfaceTypeDefinition UnionTypeDefinition: resolve_type function two parameters: x (pre-resolved   object value) schema (full Schema definition). function   required determine object type used.   resolve_type called ObjectTypeDefinition   resolve methods called. description (optional) single   character value describes object","code":""},{"path":"http://schloerke.com/gqlr/reference/gqlr_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Schema definitions — gqlr_schema","text":"","code":"# \\donttest{ library(magrittr)  ## Set up data add_human <- function(human_data, id, name, appear, home, friend) {   human <- list(id = id, name = name, appearsIn = appear, friends = friend, homePlanet = home)   # set up a function to be calculated if the field totalCredits is required   human$totalCredits <- function(obj, args, schema) {     length(human$appearsIn)   }   human_data[[id]] <- human   human_data } add_droid <- function(droid_data, id, name, appear, pf, friend) {   droid <- list(id = id, name = name, appearsIn = appear, friends = friend, primaryFunction = pf)   # set extra fields manually   droid$totalCredits <- length(droid$appearsIn)   droid_data[[id]] <- droid   droid_data }  human_data <- list() %>%   add_human(\"1000\", \"Luke Skywalker\", c(4, 5, 6), \"Tatooine\", c(\"1002\", \"1003\", \"2000\", \"2001\")) %>%   add_human(\"1002\", \"Han Solo\",       c(4, 5, 6), \"Corellia\", c(\"1000\", \"1003\", \"2001\")) %>%   add_human(\"1003\", \"Leia Organa\",    c(4, 5, 6), \"Alderaan\", c(\"1000\", \"1002\", \"2000\", \"2001\"))  droid_data <- list() %>%   add_droid(\"2000\", \"C-3PO\", c(4, 5, 6), \"Protocol\", c(\"1000\", \"1002\", \"1003\", \"2001\")) %>%   add_droid(\"2001\", \"R2-D2\", c(4, 5, 6), \"Astromech\", c(\"1000\", \"1002\", \"1003\"))  all_characters <- list() %>% append(human_data) %>% append(droid_data) %>% print() #> $`1000` #> $`1000`$id #> [1] \"1000\" #>  #> $`1000`$name #> [1] \"Luke Skywalker\" #>  #> $`1000`$appearsIn #> [1] 4 5 6 #>  #> $`1000`$friends #> [1] \"1002\" \"1003\" \"2000\" \"2001\" #>  #> $`1000`$homePlanet #> [1] \"Tatooine\" #>  #> $`1000`$totalCredits #> function(obj, args, schema) { #>     length(human$appearsIn) #>   } #> <environment: 0x56438d772f10> #>  #>  #> $`1002` #> $`1002`$id #> [1] \"1002\" #>  #> $`1002`$name #> [1] \"Han Solo\" #>  #> $`1002`$appearsIn #> [1] 4 5 6 #>  #> $`1002`$friends #> [1] \"1000\" \"1003\" \"2001\" #>  #> $`1002`$homePlanet #> [1] \"Corellia\" #>  #> $`1002`$totalCredits #> function(obj, args, schema) { #>     length(human$appearsIn) #>   } #> <environment: 0x56438d7721b8> #>  #>  #> $`1003` #> $`1003`$id #> [1] \"1003\" #>  #> $`1003`$name #> [1] \"Leia Organa\" #>  #> $`1003`$appearsIn #> [1] 4 5 6 #>  #> $`1003`$friends #> [1] \"1000\" \"1002\" \"2000\" \"2001\" #>  #> $`1003`$homePlanet #> [1] \"Alderaan\" #>  #> $`1003`$totalCredits #> function(obj, args, schema) { #>     length(human$appearsIn) #>   } #> <environment: 0x56438d7753a8> #>  #>  #> $`2000` #> $`2000`$id #> [1] \"2000\" #>  #> $`2000`$name #> [1] \"C-3PO\" #>  #> $`2000`$appearsIn #> [1] 4 5 6 #>  #> $`2000`$friends #> [1] \"1000\" \"1002\" \"1003\" \"2001\" #>  #> $`2000`$primaryFunction #> [1] \"Protocol\" #>  #> $`2000`$totalCredits #> [1] 3 #>  #>  #> $`2001` #> $`2001`$id #> [1] \"2001\" #>  #> $`2001`$name #> [1] \"R2-D2\" #>  #> $`2001`$appearsIn #> [1] 4 5 6 #>  #> $`2001`$friends #> [1] \"1000\" \"1002\" \"1003\" #>  #> $`2001`$primaryFunction #> [1] \"Astromech\" #>  #> $`2001`$totalCredits #> [1] 3 #>  #>  ## End data set up    # Define the schema using GraphQL code star_wars_schema <- Schema$new()  \" enum Episode { NEWHOPE, EMPIRE, JEDI } \" %>%   gqlr_schema(     Episode = list(       resolve = function(episode_id, schema) {         switch(as.character(episode_id),           \"4\" = \"NEWHOPE\",           \"5\" = \"EMPIRE\",           \"6\" = \"JEDI\",           \"UNKNOWN_EPISODE\"         )       }     )   ) -> episode_schema # display the schema episode_schema$get_schema() #> <graphql definition> #>   | enum Episode { #>   |   NEWHOPE #>   |   EMPIRE #>   |   JEDI #>   | } # add the episode definitions to the Star Wars schema star_wars_schema$add(episode_schema)   \" interface Character {   id: String!   name: String   friends: [Character]   appearsIn: [Episode] } \" %>%   gqlr_schema(     Character = list(       resolve_type = function(id, schema) {         if (id %in% names(droid_data)) {           \"Droid\"         } else {           \"Human\"         }       }     )   ) -> character_schema # print the Character schema with no extra formatting character_schema$get_schema() %>% format() %>% cat(\"\\n\") #> interface Character { #>   id: String! #>   name: String #>   friends: [Character] #>   appearsIn: [Episode] #> }  star_wars_schema$add(character_schema)   \" type Droid implements Character {   id: String!   name: String   friends: [Character]   appearsIn: [Episode]   primaryFunction: String } type Human implements Character {   id: String!   name: String   friends: [Character]   appearsIn: [Episode]   homePlanet: String } \" %>%   gqlr_schema(     Human = list(       # Add a resolve method for type Human that takes in an id and returns the human data       resolve = function(id, args, schema) {         human_data[[id]]       }     ),     Droid = list(       # description for Droid       description = \"A mechanical creature in the Star Wars universe.\",       # Add a resolve method for type Droid that takes in an id and returns the droid data       resolve = function(id, schema) {         droid_data[[id]]       }     )   ) -> human_and_droid_schema human_and_droid_schema$get_schema() #> <graphql definition> #>   | type Droid implements Character { #>   |   id: String! #>   |   name: String #>   |   friends: [Character] #>   |   appearsIn: [Episode] #>   |   primaryFunction: String #>   | } #>   |  #>   | type Human implements Character { #>   |   id: String! #>   |   name: String #>   |   friends: [Character] #>   |   appearsIn: [Episode] #>   |   homePlanet: String #>   | } star_wars_schema$add(human_and_droid_schema)   \" type Query {   hero(episode: Episode): Character   human(id: String!): Human   droid(id: String!): Droid } # the schema type must be provided if a query or mutation is to be executed schema {   query: Query } \" %>%   gqlr_schema(     Query = function(null, schema) {       list(         # return a function for key 'hero'         # the id will be resolved by the appropriate resolve() method of Droid or Human         hero = function(obj, args, schema) {           episode <- args$episode           if (identical(episode, 5) || identical(episode, \"EMPIRE\")) {             \"1000\" # Luke Skywalker           } else {             \"2001\" # R2-D2           }         },         # the id will be resolved by the Human resolve() method         human = function(obj, args, schema) {           args$id         },         # the id will be resolved by the Droid resolve() method         droid = function(obj, args, schema) {           args$id         }       )     }   ) -> schema_def # print Schema with no extra formatting schema_def$get_schema() %>% format() %>% cat(\"\\n\") #> type Query { #>   hero(episode: Episode): Character #>   human(id: String!): Human #>   droid(id: String!): Droid #> } #>  #> schema { #>   query: Query #> }  star_wars_schema$add(schema_def)   # view the final schema definitiion star_wars_schema$get_schema() #> <graphql definition> #>   | enum Episode { #>   |   NEWHOPE #>   |   EMPIRE #>   |   JEDI #>   | } #>   |  #>   | type Droid implements Character { #>   |   id: String! #>   |   name: String #>   |   friends: [Character] #>   |   appearsIn: [Episode] #>   |   primaryFunction: String #>   | } #>   |  #>   | type Human implements Character { #>   |   id: String! #>   |   name: String #>   |   friends: [Character] #>   |   appearsIn: [Episode] #>   |   homePlanet: String #>   | } #>   |  #>   | type Query { #>   |   hero(episode: Episode): Character #>   |   human(id: String!): Human #>   |   droid(id: String!): Droid #>   | } #>   |  #>   | interface Character { #>   |   id: String! #>   |   name: String #>   |   friends: [Character] #>   |   appearsIn: [Episode] #>   | } #>   |  #>   | schema { #>   |   query: Query #>   | } # }"},{"path":"http://schloerke.com/gqlr/reference/parse_ast.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse AST — parse_ast","title":"Parse AST — parse_ast","text":"helper function Scalars.  Given particular kind resolve function, produces function parse values particular kind.","code":""},{"path":"http://schloerke.com/gqlr/reference/parse_ast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse AST — parse_ast","text":"","code":"parse_ast(kind, resolve)"},{"path":"http://schloerke.com/gqlr/reference/parse_ast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse AST — parse_ast","text":"kind single character name class parse resolve function parse value kind correct","code":""},{"path":"http://schloerke.com/gqlr/reference/parse_ast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse AST — parse_ast","text":"function takes obj schema parse   value kind inherited obj","code":""},{"path":"http://schloerke.com/gqlr/reference/parse_ast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse AST — parse_ast","text":"Typically, kind class Scalar.  making new Scalar, parse_ast defaults use name scalar scalar's parse value function. function need used defining schema gqlr_schema()","code":""},{"path":"http://schloerke.com/gqlr/reference/parse_ast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse AST — parse_ast","text":"","code":"parse_date_value <- function(obj, schema) {   as.Date(obj) } parse_ast(\"Date\", parse_date_value) #> function (obj, schema)  #> { #>     if (inherits(obj, \"Date\")) { #>         (function (obj, schema)  #>         { #>             as.Date(obj) #>         })(obj$value, schema) #>     } #>     else { #>         NULL #>     } #> } #> <environment: namespace:gqlr>  # Example from Int scalar parse_int <- function(value, ...) {   MAX_INT <-  2147483647   MIN_INT <- -2147483648   num <- suppressWarnings(as.integer(value))   if (!is.na(num)) {     if (num <= MAX_INT && num >= MIN_INT) {       return(num)     }   }   return(NULL) } parse_ast(\"IntValue\", parse_int) #> function (obj, schema)  #> { #>     if (inherits(obj, \"IntValue\")) { #>         (function (value, ...)  #>         { #>             MAX_INT <- 2147483647 #>             MIN_INT <- -2147483648 #>             num <- suppressWarnings(as.integer(value)) #>             if (!is.na(num)) { #>                 if (num <= MAX_INT && num >= MIN_INT) { #>                   return(num) #>                 } #>             } #>             return(NULL) #>         })(obj$value, schema) #>     } #>     else { #>         NULL #>     } #> } #> <environment: namespace:gqlr>"},{"path":"http://schloerke.com/gqlr/reference/server.html","id":null,"dir":"Reference","previous_headings":"","what":"Run basic GraphQL server with GraphiQL support — server","title":"Run basic GraphQL server with GraphiQL support — server","text":"Run basic GraphQL server using plumber.  server provided show basic interaction GraphQL.  server run function execution canceled.","code":""},{"path":"http://schloerke.com/gqlr/reference/server.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run basic GraphQL server with GraphiQL support — server","text":"","code":"server(   schema,   port = 8000L,   ...,   graphiql = interactive(),   log = TRUE,   initial_value = NULL )"},{"path":"http://schloerke.com/gqlr/reference/server.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run basic GraphQL server with GraphiQL support — server","text":"schema Schema object use execute requests port web port serve server .  Set port NULL run plumber server return . ... ignored paramter expansion graphiql logical determine GraphiQL interface enabled.  default, route available running server interactively. log boolean determines server logging done.  Defaults TRUE initial_value default value use execute_request()","code":""},{"path":"http://schloerke.com/gqlr/reference/server.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run basic GraphQL server with GraphiQL support — server","text":"view GraphiQL user interface, navigate URL provided server started.  default location http://localhost:8000/graphiql/. default, route available running server interactively (graphiql = rlang::is_interactive()). server() implements basic necessities described http://graphql.org/learn/serving--http/.  four routes implemented: '/' GET. run interactively, forwards /graphiql user interaction GraphQL server. route diabled graphiql = rlang::is_interactive() TRUE. '/graphiql/' GET. Returns GraphiQL formatted schema definition interface manually interact GraphQL server. default route disabled graphiql = rlang::is_interactive() TRUE. '/graphql' GET. Executes query.  parameter 'query' (contains GraphQL formatted query string) must included.  Optional parameters include: 'variables' JSON string containing dictionary variables (defaults empty named list), 'operationName' name particular query operation execute (defaults NULL), 'pretty' boolean determine response compact (FALSE, default) expanded (TRUE) '/graphql' POST. Executes query.  Must provide Content-Type either 'application/json' 'application/graphql'. 'application/json' provided, named JSON list containing 'query', 'operationName' (optional, default = NULL), 'variables' (optional, default = list()) 'pretty' (optional, default = TRUE).  information used just GET-'/graphql' route. 'application/graphql' provided, POST body interpreted query string.  possible parameters take default value. Using bash's curl, can ask server questions:","code":"#R   # load Star Wars schema from 'execute_request' example   example(gqlr_schema)   # run server   server(star_wars_schema, port = 8000) #bash   # GET Schema definition   curl '127.0.0.1:8000/'    ## POST for R2-D2 and his friends' names   # defaults to parse as JSON   curl --data '{\"query\":\"{hero{name, friends { name }}}\", \"pretty\": true}' '127.0.0.1:8000/graphql'   # send json header   curl --data '{\"query\":\"{hero{name, friends { name }}}\"}' '127.0.0.1:8000/graphql' --header \"Content-Type:application/json\"   # send graphql header   curl --data '{hero{name, friends { name }}}' '127.0.0.1:8000/graphql' --header \"Content-Type:application/graphql\"   # use variables   curl --data '{\"query\":\"query Droid($someId: String!) {droid(id: $someId) {name, friends { name }}}\", \"variables\": {\"someId\": \"2001\"}}' '127.0.0.1:8000/graphql'    # GET R2-D2 and his friends' names   curl '127.0.0.1:8000/graphql?query=   # ... using a variable   curl '127.0.0.1:8000/graphql?query=query"},{"path":[]},{"path":"http://schloerke.com/gqlr/news/index.html","id":"breaking-changes-development-version","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"gqlr (development version)","text":"... added server() ahead log= initial_value=. two paramters must now named. (#11) ... added execute_request() ahead operation_name=, variables=, initialial_value=. parameters must now named. (#11) server()’s / route now redirects /graphiql iff server(graphiql=TRUE). (#11)","code":""},{"path":"http://schloerke.com/gqlr/news/index.html","id":"new-features-and-improvements-development-version","dir":"Changelog","previous_headings":"","what":"New features and improvements","title":"gqlr (development version)","text":"Add support GraphiQL. view GraphiQL interface schema, run gqlr::server(MY_SCHEMA, graphiql = TRUE) visit http://localhost:8000/graphiql/. default, GraphiQL suport enabled run interactively. (#11) Add support execute_request(verbose_errors=). TRUE (legacy behavior), error-like messages displayed real time. default, value TRUE run interactively. (#11) Remove __typename fields. meta field attached object structure. (#11)","code":""},{"path":"http://schloerke.com/gqlr/news/index.html","id":"bug-fixes-development-version","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"gqlr (development version)","text":"Fix bug mutation execution query operation used validation (#9) Add support introspection type subscriptionType value return NULL signify supported. (#11)","code":""},{"path":"http://schloerke.com/gqlr/news/index.html","id":"gqlr-002","dir":"Changelog","previous_headings":"","what":"gqlr 0.0.2","title":"gqlr 0.0.2","text":"CRAN release: 2019-12-02 Export server function Use plumber instead jug server function Fix R installation bug Delay evaluation R6 class definitions .onLoad call avoid long compile times large compiled files","code":""},{"path":"http://schloerke.com/gqlr/news/index.html","id":"gqlr-001","dir":"Changelog","previous_headings":"","what":"gqlr 0.0.1","title":"gqlr 0.0.1","text":"CRAN release: 2017-06-07 Initial release","code":""}]
